// SPDX-License-Identifier: MIT
// Optimized Q8_0 dequant + matrix-vector multiply with subgroup reduction and multi-row.
// dst[row] = sum_j(dequant(W_q8[row,j]) * x[j])
// 4 rows per workgroup, 256 threads, subgroup arithmetic reduction.
//
// Q8_0 format: blocks of 32 elements, 34 bytes each:
//   - 2 bytes: fp16 scale (d)
//   - 32 bytes: int8 quantized values (qs[32])
#version 450

#extension GL_KHR_shader_subgroup_arithmetic : require

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer XBuffer { float x[]; };
layout(std430, binding = 1) readonly buffer WBuffer { uint W_raw[]; };
layout(std430, binding = 2) writeonly buffer DstBuffer { float dst[]; };

layout(push_constant) uniform PushConstants {
    uint N;
    uint K;
    uint row0;
} pc;

shared float s_partial[4][4];

float fp16_to_f32(uint h) {
    uint sign = (h >> 15) & 1u;
    uint expo = (h >> 10) & 0x1Fu;
    uint mant = h & 0x3FFu;
    float val;
    if (expo == 0u) {
        val = ldexp(float(mant), -24);
    } else if (expo == 31u) {
        val = (mant == 0u) ? uintBitsToFloat(0x7F800000u) : uintBitsToFloat(0x7FC00000u);
    } else {
        val = ldexp(float(mant | 0x400u), int(expo) - 25);
    }
    return (sign != 0u) ? -val : val;
}

// Process one Q8_0 block for a given row, accumulate into sum
float processBlock(uint row_byte_offset, uint b, uint n_blocks) {
    uint block_byte = row_byte_offset + b * 34u;

    // Read fp16 scale
    uint scale_word = W_raw[block_byte >> 2u];
    uint byte_in_word = block_byte & 3u;
    uint scale_bits;
    if (byte_in_word == 0u) {
        scale_bits = scale_word & 0xFFFFu;
    } else if (byte_in_word == 2u) {
        scale_bits = (scale_word >> 16u) & 0xFFFFu;
    } else if (byte_in_word == 3u) {
        uint next_word = W_raw[(block_byte >> 2u) + 1u];
        scale_bits = ((scale_word >> 24u) & 0xFFu) | ((next_word & 0xFFu) << 8u);
    } else {
        scale_bits = (scale_word >> (byte_in_word * 8u)) & 0xFFFFu;
    }
    float d = fp16_to_f32(scale_bits);

    uint qs_byte_start = block_byte + 2u;
    uint col_start = b * 32u;
    float sum = 0.0;

    for (uint i = 0u; i < 32u; i += 4u) {
        uint col = col_start + i;
        if (col >= pc.K) break;

        uint byte_off = qs_byte_start + i;
        uint word_idx = byte_off >> 2u;
        uint shift = (byte_off & 3u) * 8u;

        uint packed;
        if (shift == 0u) {
            packed = W_raw[word_idx];
        } else {
            packed = (W_raw[word_idx] >> shift) | (W_raw[word_idx + 1u] << (32u - shift));
        }

        int q0 = int(packed << 24u) >> 24;
        int q1 = int(packed << 16u) >> 24;
        int q2 = int(packed << 8u) >> 24;
        int q3 = int(packed) >> 24;

        sum += d * float(q0) * x[col];
        if (col + 1u < pc.K) sum += d * float(q1) * x[col + 1u];
        if (col + 2u < pc.K) sum += d * float(q2) * x[col + 2u];
        if (col + 3u < pc.K) sum += d * float(q3) * x[col + 3u];
    }
    return sum;
}

void main() {
    uint base_row = gl_WorkGroupID.x * 4u;
    uint tid = gl_LocalInvocationID.x;
    uint sg_id = gl_SubgroupID;
    uint sg_size = gl_SubgroupSize;

    uint n_blocks = (pc.K + 31u) / 32u;

    float sum0 = 0.0, sum1 = 0.0, sum2 = 0.0, sum3 = 0.0;

    for (uint b = tid; b < n_blocks; b += 256u) {
        if (base_row < pc.N)
            sum0 += processBlock((pc.row0 + base_row) * n_blocks * 34u, b, n_blocks);
        if (base_row + 1u < pc.N)
            sum1 += processBlock((pc.row0 + base_row + 1u) * n_blocks * 34u, b, n_blocks);
        if (base_row + 2u < pc.N)
            sum2 += processBlock((pc.row0 + base_row + 2u) * n_blocks * 34u, b, n_blocks);
        if (base_row + 3u < pc.N)
            sum3 += processBlock((pc.row0 + base_row + 3u) * n_blocks * 34u, b, n_blocks);
    }

    // Subgroup reduction
    sum0 = subgroupAdd(sum0);
    sum1 = subgroupAdd(sum1);
    sum2 = subgroupAdd(sum2);
    sum3 = subgroupAdd(sum3);

    if (gl_SubgroupInvocationID == 0u) {
        s_partial[sg_id][0] = sum0;
        s_partial[sg_id][1] = sum1;
        s_partial[sg_id][2] = sum2;
        s_partial[sg_id][3] = sum3;
    }

    barrier();

    if (sg_id == 0u && gl_SubgroupInvocationID < 4u) {
        uint n_sg = (256u + sg_size - 1u) / sg_size;
        float r0 = 0.0, r1 = 0.0, r2 = 0.0, r3 = 0.0;
        uint lane = gl_SubgroupInvocationID;
        if (lane < n_sg) {
            r0 = s_partial[lane][0];
            r1 = s_partial[lane][1];
            r2 = s_partial[lane][2];
            r3 = s_partial[lane][3];
        }
        r0 = subgroupAdd(r0);
        r1 = subgroupAdd(r1);
        r2 = subgroupAdd(r2);
        r3 = subgroupAdd(r3);

        if (lane == 0u) {
            if (base_row < pc.N) dst[base_row] = r0;
            if (base_row + 1u < pc.N) dst[base_row + 1u] = r1;
            if (base_row + 2u < pc.N) dst[base_row + 2u] = r2;
            if (base_row + 3u < pc.N) dst[base_row + 3u] = r3;
        }
    }
}
